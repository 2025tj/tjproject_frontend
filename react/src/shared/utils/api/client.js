//axios Ïù∏Ïä§ÌÑ¥Ïä§ ÏÑ§Ï†ï + ÌÜ†ÌÅ∞ Í∞±Ïã† Ïù∏ÌÑ∞ÏÖâÌÑ∞
import axios from 'axios'
import { saveAccessFromHeaders, isTokenExpiringSoon, getAccessToken, clearAccessToken } from '@features/auth/utils'

// Ïù∏Ï¶ù ÏóÜÏù¥ Ï†ëÍ∑º Í∞ÄÎä•Ìïú Í≤ΩÎ°ú
const NO_AUTH_ENDPOINTS=['/auth/login', '/auth/signup', '/auth/refresh']

// 1) axios Ïù∏Ïä§ÌÑ¥Ïä§
const api = axios.create({
    baseURL: 'http://localhost:8080/api',
    withCredentials: true, // Ïø†ÌÇ§ Ìè¨Ìï® ÏöîÏ≤≠ ÌóàÏö©
})

// Î¶¨ÌîÑÎ†àÏãú Ï†ÑÏö© Ïù∏Ïä§ÌÑ¥Ïä§ (Ïù∏ÌÑ∞ÏÖâÌÑ∞ ÏóÜÏù¥ Ïò§Î°úÏßÄ Ïø†ÌÇ§Îßå ÏûêÎèô Ï†ÑÏÜ°)
export const refreshApi = axios.create({
  baseURL: 'http://localhost:8080/api/auth',
  withCredentials: true,
})

let onAuthError = null // ÏΩúÎ∞± Ï¥àÍ∏∞Ìôî

export const setAuthErrorHandler = (fn) => {
  onAuthError = fn
}

//Ïã±Í∏ÄÌîåÎùºÏù¥Ìä∏(1Î≤àÎßå Í∞±Ïã†) ÏÉÅÌÉúÍ¥ÄÎ¶¨ Î≥ÄÏàò
let refreshPromise = null // ÌòÑÏû¨ ÏßÑÌñâÏ§ëÏù∏ refreshÏöîÏ≤≠ Promise
let subscribers = []      // refresh ÏôÑÎ£åÎ•º Í∏∞Îã§Î¶¨Îäî ÎåÄÍ∏∞ ÏöîÏ≤≠Îì§Ïùò ÏΩúÎ∞± Î¶¨Ïä§Ìä∏

// refresh ÏÑ±Í≥µÏãú ÏÉà accessTokenÏùÑ ÎåÄÍ∏∞Ï§ëÏù∏ ÏöîÏ≤≠Îì§Ïóê Ï†ÑÎã¨
const onRefreshed = (newAccessToken) => {
  subscribers.forEach((callback) => callback(newAccessToken))
  subscribers = [] // ÏΩúÎ∞± Î™®Îëê Ìò∏Ï∂ú ÌõÑ ÌÅê Ï¥àÍ∏∞Ìôî
}

// ÌòÑÏû¨ refreshÍ∞Ä ÏßÑÌñâÏ§ëÏù¥Î©¥, Ìï¥Îãπ refreshÍ∞Ä ÎÅùÎÇú Îí§ Ïû¨ÏãúÎèÑÌï†ÏàòÏûàÎèÑÎ°ù ÏΩúÎ∞± Îì±Î°ù
const subscribeTokenRefresh = (callback) => {
  subscribers.push(callback)
}

// ÏöîÏ≤≠ Ïù∏ÌÑ∞ÏÖâÌÑ∞ - ÎîîÎ≤ÑÍπÖ Î°úÍ∑∏ Ìè¨Ìï®
api.interceptors.request.use(
  async (config) => {
    console.log('üöÄ [API Client] ÏöîÏ≤≠ ÏãúÏûë:', config.method?.toUpperCase(), config.url)
    
    const url = config.url || ''
    if (NO_AUTH_ENDPOINTS.some((u) => url.includes(u))) return config

    // ÌòÑÏû¨ Ï†ÄÏû•Îêú ÌÜ†ÌÅ∞ ÌôïÏù∏
    const token = getAccessToken()
    console.log('üîç [API Client] Ï†ÄÏû•Îêú ÌÜ†ÌÅ∞:', token ? `${token.substring(0, 20)}...` : 'null')
    
    if (token) {
      config.headers = config.headers || {}
      config.headers.Authorization = `Bearer ${token}`
    }
    return config
    // if (token) {
    //   // Authorization Ìó§ÎçîÏóê ÌÜ†ÌÅ∞ Ìè¨Ìï®
    //   config.headers = config.headers || {}
    //   config.headers.Authorization = `Bearer ${token}`
    //   console.log('‚úÖ [API Client] Authorization Ìó§Îçî ÏÑ§Ï†ïÎê®:', `Bearer ${token.substring(0, 20)}...`)
      
    //   // ÌÜ†ÌÅ∞ ÎßåÎ£å ÌôïÏù∏
    //   if (isTokenExpiringSoon(token, 120)) {
    //     console.log('‚è∞ [API Client] ÌÜ†ÌÅ∞ ÎßåÎ£å ÏûÑÎ∞ï - Í∞±Ïã† ÏãúÎèÑ')
    //     try {
    //       const refreshRes = await refreshApi.post('/refresh')
    //       const newToken = saveAccessFromHeaders(refreshRes.headers)
          
    //       if (newToken) {
    //         config.headers.Authorization = `Bearer ${newToken}`
    //         console.log('üîÑ [API Client] ÌÜ†ÌÅ∞ Í∞±Ïã† ÏÑ±Í≥µ')
    //       }
    //     } catch (err) {
    //       console.warn('‚ö†Ô∏è [API Client] ÌÜ†ÌÅ∞ Í∞±Ïã† Ïã§Ìå®:', err)
    //     }
    //   }
    // } else {
    //   console.warn('‚ö†Ô∏è [API Client] ÌÜ†ÌÅ∞Ïù¥ ÏóÜÏäµÎãàÎã§ - Authorization Ìó§Îçî ÏóÜÏù¥ ÏöîÏ≤≠')
    // }
    
    // console.log('üîç [API Client] ÏµúÏ¢Ö ÏöîÏ≤≠ Ìó§Îçî:', config.headers)
    // return config
  },
  (error) => {
    console.error('‚ùå [API Client] ÏöîÏ≤≠ Ïù∏ÌÑ∞ÏÖâÌÑ∞ ÏóêÎü¨:', error)
    return Promise.reject(error)
  }
)

// ÏùëÎãµ Ïù∏ÌÑ∞ÏÖâÌÑ∞ - 401ÏóêÏÑú ÌïúÎ≤àÎßå refersh
api.interceptors.response.use(
  (response) => {
    console.log('‚úÖ [API Client] ÏùëÎãµ ÏÑ±Í≥µ:', {
      url: response.config.url || '',
      status: response.status,
      hasHeaders: !!response.headers
    })
    
    // Ïù∏Ï¶ù Í¥ÄÎ†® ÏùëÎãµ Ï≤òÎ¶¨
    const authUrls = ['/auth/login', '/auth/refresh', '/auth/oauth2/complete']
    const isAuthResponse = authUrls.some(url => response.config.url?.includes(url))
    
    if (isAuthResponse) {
      console.log('üîê [API Client] Ïù∏Ï¶ù ÏùëÎãµ Í∞êÏßÄ')
      console.log('üîç [API Client] ÏùëÎãµ Ìó§Îçî ÏÉÅÏÑ∏:', response.headers)
      
      if (response.headers) {
        // Ìó§Îçî ÌÇ§Îì§ ÌôïÏù∏
        const headerKeys = Object.keys(response.headers)
        console.log('üîç [API Client] Ìó§Îçî ÌÇ§ Î™©Î°ù:', headerKeys)
        
        // ÌäπÏ†ï ÌÜ†ÌÅ∞ Ìó§ÎçîÎì§ ÌôïÏù∏
        const tokenHeaders = ['Access-Token', 'access-token', 'Authorization', 'authorization']
        tokenHeaders.forEach(headerName => {
          if (response.headers[headerName]) {
            console.log(`üîç [API Client] ${headerName} Ìó§Îçî Î∞úÍ≤¨:`, response.headers[headerName])
          }
        })
        
        const savedToken = saveAccessFromHeaders(response.headers)
        if (savedToken) {
          console.log('‚úÖ [API Client] ÌÜ†ÌÅ∞ Ï†ÄÏû• ÏÑ±Í≥µ:', `${savedToken.substring(0, 20)}...`)
        } else {
          console.warn('‚ö†Ô∏è [API Client] ÌÜ†ÌÅ∞ Ï†ÄÏû• Ïã§Ìå® - Ìó§ÎçîÏóêÏÑú ÌÜ†ÌÅ∞ÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏùå')
          console.warn('‚ö†Ô∏è [API Client] ÏÇ¨Ïö© Í∞ÄÎä•Ìïú Ìó§Îçî:', headerKeys)
        }
      } else {
        console.warn('‚ö†Ô∏è [API Client] Ïù∏Ï¶ù ÏùëÎãµÏóê Ìó§ÎçîÍ∞Ä ÏóÜÏùå')
      }
    }
    
    return response
  },
  async (error) => {
    const status = error.response?.status
    const originalRequest = error.config || {}
    const url = originalRequest.url || ''
    console.error('‚ùå [API Client] ÏùëÎãµ ÏóêÎü¨:', {
      url: error.config?.url,
      status: error.response?.status,
      message: error.message
    })

    // ÏòàÏô∏ ÏóîÎìúÌè¨Ïù∏Ìä∏(Î°úÍ∑∏Ïù∏/ÌöåÏõêÍ∞ÄÏûÖ/Î¶¨ÌîÑÎ†àÏãú)Îäî 401Ïù¥Ïñ¥ÎèÑ Ïû¨ÏãúÎèÑÌïòÏßÄÏïäÍ≥† Ïã§Ìå® Ï†ÑÎã¨
    if (NO_AUTH_ENDPOINTS.some((u) => url.includes(u))) {
      return Promise.reject(error)
    }

    // 401Ïù¥Î©¥ÏÑú ÏïÑÏßÅ Ïû¨ÏãúÎèÑ ÏïàÌïú ÏöîÏ≤≠ Ï≤òÎ¶¨
    if (status === 401 && !originalRequest._retry) {
      originalRequest._retry= true // Î¨¥ÌïúÎ£®ÌîÑÎ∞©ÏßÄ

      try {
        // Ïù¥ÎØ∏ Îã§Î•∏ ÏöîÏ≤≠Ïù¥ refreshÏ§ëÏù¥Î©¥: refresh ÏôÑÎ£åÍπåÏßÄ ÎåÄÍ∏∞ÌñàÎã§Í∞Ä ÏÉà ÌÜ†ÌÅ∞ÏúºÎ°ú Ïû¨ÏãúÎèÑ
        if (refreshPromise) {
          return new Promise((resolve) => {
            subscribeTokenRefresh((newAccess) => {
              originalRequest.headers = originalRequest.headers || {}
              originalRequest.headers.Authorization = `Bearer ${newAccess}`
              resolve(api(originalRequest)) // ÏÉàÌÜ†ÌÅ∞ÏúºÎ°ú Ïõê ÏöîÏ≤≠ Ïû¨ÏãúÎèÑ
            })
          })
        }

        // Ïù¥ÌõÑ ÌòÑ Ïä§Î†àÎìúÍ∞Ä refresh Îã¥Îãπ(Ïã±Í∏ÄÌîåÎùºÏù¥Ìä∏ ÏãúÏûë)
        refreshPromise = refreshApi.post('/refresh') // Ïø†ÌÇ§Î°ú Ïù∏Ï¶ù
        const resfreshRes = await refreshPromise    // refresh ÏôÑÎ£åÍπåÏßÄ ÎåÄÍ∏∞
        refreshPromise = null                       // ÏôÑÎ£åÏãú Ï¥àÍ∏∞Ìôî

        // ÏÉà accessTokenÏùÑ ÏùëÎãµÌó§ÎçîÏóêÏÑú Í∫ºÎÇ¥ Ï†ÄÏû•(Ìó§ÎçîÌÇ§Îäî ÏÜåÎ¨∏Ïûê)
        const newToken = saveAccessFromHeaders(refreshRes.headers)
        if (!newToken) {
          // ÏÑúÎ≤ÑÍ∞Ä bodyÎ°ú Ï£ºÎäî Íµ¨Ï°∞Î©¥ bodyÏóêÏÑú Í∫ºÎÇ¥ Ï†ÄÏû•ÌïòÎèÑÎ°ù Î≥ÄÍ≤ΩÌïÑÏöî
          throw new Error('No access token in refresh response')
        }

        // refresh ÎåÄÍ∏∞Ï§ëÏù¥Î©¥ ÏöîÏ≤≠Îì§ Î™®Îëê Í∫†ÏõåÏÑú ÏÉà ÌÜ†ÌÅ∞ Ï†ÑÎã¨
        onRefreshed(newToken)

        // Î∞©Í∏à Ïã§Ìå®ÌñàÎçò Ïõê ÏöîÏ≤≠ÎèÑ ÏÉà ÌÜ†ÌÅ∞ÏúºÎ°ú Ïû¨ÏãúÎèÑ
        originalRequest.headers = originalRequest.headers || {}
        originalRequest.headers.Authorization = `Bearer ${newToken}`
        return api(originalRequest)
      } catch (e) {
        // refresh ÏûêÏ≤¥Í∞Ä Ïã§Ìå®Ïãú Ïù∏Ï¶ùÏÉÅÌÉúÏ†ïÎ¶¨ ÌõÑ Ïï± Î†àÎ≤®ÏóêÏÑú Ï≤òÎ¶¨
        refreshPromise = null
        clearAccessToken()
        onAuthError?.() // Ïòà: store Ï¥àÍ∏∞Ìôî ÌõÑ /login Ïù¥Îèô
        return Promise.reject(e)
      }
    }

    // Í∑∏ Ïô∏ ÏóêÎü¨Îäî Í∑∏ÎåÄÎ°ú Ï†ÑÎã¨
    return Promise.reject(error)

  //   // 401 ÏóêÎü¨ Ï≤òÎ¶¨
  //   if (error.response?.status === 401) {
  //     console.log('üîê [API Client] 401 Unauthorized - ÌÜ†ÌÅ∞ Î¨∏Ï†ú Í∞ÄÎä•ÏÑ±')
      
  //     const originalRequest = error.config
  //     const excludeUrls = ['/login', '/signup', '/refresh']
      
  //     if (!excludeUrls.some(url => originalRequest.url?.includes(url)) && !originalRequest._retry) {
  //       console.log('üîÑ [API Client] ÌÜ†ÌÅ∞ Í∞±Ïã† Î∞è Ïû¨ÏãúÎèÑ ÏãúÏûë')
  //       originalRequest._retry = true // Î¨¥ÌïúÎ£®ÌîÑ Î∞©ÏßÄ

  //       try {
  //         const refreshRes = await refreshApi.post('/refresh')
  //         const newToken = saveAccessFromHeaders(refreshRes.headers)
          
  //         if (newToken) {
  //           console.log('‚úÖ [API Client] ÌÜ†ÌÅ∞ Í∞±Ïã† ÏÑ±Í≥µ - ÏöîÏ≤≠ Ïû¨ÏãúÎèÑ')
  //           originalRequest.headers.Authorization = `Bearer ${newToken}`
  //           return api(originalRequest)
  //         }
  //       } catch (refreshError) {
  //         console.error('‚ùå [API Client] ÌÜ†ÌÅ∞ Í∞±Ïã† Ïã§Ìå®:', refreshError)
  //         clearAccessToken()
          
  //         if (!window.location.pathname.includes('/login')) {
  //           console.log('üîÑ [API Client] Î°úÍ∑∏Ïù∏ ÌéòÏù¥ÏßÄÎ°ú Î¶¨Îã§Ïù¥Î†âÌä∏')
  //           window.location.href = '/login'
  //         }
  //       }
  //     }
  //   }
    
  //   return Promise.reject(error)
  }
)
// // 2) ÏöîÏ≤≠ Ïù∏ÌÑ∞ÏÖâÌÑ∞: ÎßåÎ£åÏ†Ñ ÏûêÎèô refresh
// api.interceptors.request.use(async(config) => {
//     // Ïù∏Ï¶ù ÏóÜÏù¥ Ìò∏Ï∂úÎêòÎäî ÏóîÎìúÌè¨Ïù∏Ìä∏Îäî ÌÜ†ÌÅ∞ Î∂ôÏù¥ÏßÄ ÏïäÏùå
//     if (
//         NO_AUTH_ENDPOINTS.some(url => config.url.includes(url))
//     ) {
//       return config
//     }
//     const token = getAccessToken()
//     if (token && isTokenExpiringSoon(token, 120)) {
//       try {
//         const res = await refreshApi.post('/refresh')
//         saveAccessFromHeaders(res.headers)
//         const newToken = getAccessToken()
//         if (newToken) {
//           config.headers.Authorization = `Bearer ${newToken}`
//         }
//       } catch {
//         clearAccessToken()
//         // window.location.href = '/login'
//         onAuthError?.() // ÏΩúÎ∞± Ïã§Ìñâ
//       } 
//     } else if (token) {
//       //Authorization Ìó§ÎçîÏóê Î∂ôÏù¥Í∏∞
//       config.headers.Authorization = `Bearer ${token}`
//     }
//     return config;
// },(error) => Promise.reject(error))

// // 3) ÏùëÎãµ Ïù∏ÌÑ∞ÏÖâÌÑ∞ : 401 Unauthorized(ÎßåÎ£å)Ïãú refresh ÌÜ†ÌÅ∞ÏúºÎ°ú Ïû¨Î∞úÍ∏â ÏãúÎèÑ
// api.interceptors.response.use(
//   res => res,
//   async (error) => {
//     const originalRequest = error.config

//     // 1) Ïù¥ÎØ∏ retry Ï§ëÏù¥Í±∞ÎÇò, refresh Ìò∏Ï∂úÏùº Îïê Í∑∏ÎÉ• ÏõêÎûò ÏóêÎü¨ ÎçòÏßÄÍ∏∞
//     if (
//         NO_AUTH_ENDPOINTS.some(url => originalRequest.url.includes(url))
//     ) {
//       return Promise.reject(error);
//     }

//     // Ïù¥ÎØ∏ Ïû¨ÏãúÎèÑÌïú ÏöîÏ≤≠Ïù¥ ÏïÑÎãàÍ≥†, 401 ÏóêÎü¨Ïù∏ Í≤ΩÏö∞
//     if (error.response?.status === 401 && !originalRequest._retry) {
//       originalRequest._retry = true

//       try {
//         // Ïø†ÌÇ§Ïóê Îã¥Í∏¥ refreshToken ÏûêÎèô Ï†ÑÏÜ°
//         const refreshRes = await refreshApi.post('/refresh')
//         // ÏÉà accessTokenÏùÑ HeaderÏóêÏÑú Í∫ºÎÇ¥ Ï†ÄÏû•
//         saveAccessFromHeaders(refreshRes.headers)
//         const newAccessToken = getAccessToken()
//         if (newAccessToken) {
//           // ÏõêÎûò ÏöîÏ≤≠ÏóêÎèÑ ÏÉà ÌÜ†ÌÅ∞ Ïã§Ïñ¥ Ïû¨ÏãúÎèÑ
//           originalRequest.headers.Authorization = `Bearer ${newAccessToken}`
//           return api(originalRequest)
//         }
//       } catch (refreshError) {
//         // Ïû¨Î∞úÍ∏â Ïã§Ìå® Ïãú Î°úÍ∑∏Ïù∏ ÌéòÏù¥ÏßÄÎ°ú
//         clearAccessToken()
//         // window.location.href = '/login'
//         onAuthError?.() // ÏΩúÎ∞± Ïã§Ìñâ
//         return Promise.reject(refreshError)
//       }
//     }
//     return Promise.reject(error)
//   }
// )

export default api
